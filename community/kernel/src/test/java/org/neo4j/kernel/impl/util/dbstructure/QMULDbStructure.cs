using System.Collections.Generic;

/*
 * Copyright (c) 2002-2019 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Neo4j is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
namespace Org.Neo4j.Kernel.impl.util.dbstructure
{
	using Org.Neo4j.Helpers.Collection;
	using TestIndexDescriptorFactory = Org.Neo4j.Kernel.api.schema.index.TestIndexDescriptorFactory;

	//
	// GENERATED FILE. DO NOT EDIT.
	//
	// This has been generated by:
	//
	//   org.neo4j.kernel.impl.util.dbstructure.DbStructureTool
	// org.neo4j.kernel.impl.util.dbstructure.QMULDbStructure [<output source root>] <db-dir>
	//
	// (using org.neo4j.kernel.impl.util.dbstructure.InvocationTracer)
	//

	public sealed class QMULDbStructure : Visitable<DbStructureVisitor>
	{
		 public static readonly QMULDbStructure Instance = new QMULDbStructure( "Instance", InnerEnum.Instance );

		 private static readonly IList<QMULDbStructure> valueList = new List<QMULDbStructure>();

		 static QMULDbStructure()
		 {
			 valueList.Add( Instance );
		 }

		 public enum InnerEnum
		 {
			 Instance
		 }

		 public readonly InnerEnum innerEnumValue;
		 private readonly string nameValue;
		 private readonly int ordinalValue;
		 private static int nextOrdinal = 0;

		 private QMULDbStructure( string name, InnerEnum innerEnum )
		 {
			 nameValue = name;
			 ordinalValue = nextOrdinal++;
			 innerEnumValue = innerEnum;
		 }

		 public void Accept( DbStructureVisitor visitor )
		 {
			  visitor.VisitLabel( 1, "Person" );
			  visitor.VisitPropertyKey( 0, "name" );
			  visitor.VisitPropertyKey( 1, "location" );
			  visitor.VisitPropertyKey( 2, "uid" );
			  visitor.VisitPropertyKey( 3, "link" );
			  visitor.VisitPropertyKey( 4, "gender" );
			  visitor.VisitPropertyKey( 5, "email" );
			  visitor.VisitPropertyKey( 6, "education" );
			  visitor.VisitPropertyKey( 7, "work" );
			  visitor.VisitPropertyKey( 8, "node_type" );
			  visitor.VisitPropertyKey( 9, "hometown" );
			  visitor.VisitPropertyKey( 10, "birthdate" );
			  visitor.VisitPropertyKey( 11, "ids" );
			  visitor.VisitPropertyKey( 12, "created" );
			  visitor.VisitPropertyKey( 13, "since" );
			  visitor.VisitPropertyKey( 14, "location_name" );
			  visitor.VisitPropertyKey( 15, "location_lon" );
			  visitor.VisitPropertyKey( 17, "location_id" );
			  visitor.VisitPropertyKey( 16, "location_lat" );
			  visitor.VisitRelationshipType( 0, "friends" );
			  visitor.VisitRelationshipType( 1, "FRIEND" );
			  visitor.VisitIndex( TestIndexDescriptorFactory.forLabel( 1, 2 ), ":Person(uid)", 1.0d, 135164L );
			  visitor.VisitAllNodesCount( 135242L );
			  visitor.VisitNodeCount( 1, "Person", 135213L );
			  visitor.VisitRelCount( -1, -1, -1, "MATCH ()-[]->() RETURN count(*)", 4537616L );
			  visitor.VisitRelCount( 1, -1, -1, "MATCH (:Person)-[]->() RETURN count(*)", 4536688L );
			  visitor.VisitRelCount( -1, -1, 1, "MATCH ()-[]->(:Person) RETURN count(*)", 4536688L );
			  visitor.VisitRelCount( -1, 0, -1, "MATCH ()-[:friends]->() RETURN count(*)", 4537616L );
			  visitor.VisitRelCount( 1, 0, -1, "MATCH (:Person)-[:friends]->() RETURN count(*)", 4536688L );
			  visitor.VisitRelCount( -1, 0, 1, "MATCH ()-[:friends]->(:Person) RETURN count(*)", 4536688L );
			  visitor.VisitRelCount( -1, 1, -1, "MATCH ()-[:FRIEND]->() RETURN count(*)", 0L );
			  visitor.VisitRelCount( 1, 1, -1, "MATCH (:Person)-[:FRIEND]->() RETURN count(*)", 0L );
			  visitor.VisitRelCount( -1, 1, 1, "MATCH ()-[:FRIEND]->(:Person) RETURN count(*)", 0L );
		 }

		public static IList<QMULDbStructure> values()
		{
			return valueList;
		}

		public int ordinal()
		{
			return ordinalValue;
		}

		public override string ToString()
		{
			return nameValue;
		}

		public static QMULDbStructure valueOf( string name )
		{
			foreach ( QMULDbStructure enumInstance in QMULDbStructure.valueList )
			{
				if ( enumInstance.nameValue == name )
				{
					return enumInstance;
				}
			}
			throw new System.ArgumentException( name );
		}
	}

	/* END OF GENERATED CONTENT */

}