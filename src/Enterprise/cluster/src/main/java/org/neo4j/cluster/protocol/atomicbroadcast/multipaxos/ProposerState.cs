using System.Collections.Generic;

/*
 * Copyright (c) 2002-2018 "Neo4j,"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j Enterprise Edition. The included source
 * code can be redistributed and/or modified under the terms of the
 * GNU AFFERO GENERAL PUBLIC LICENSE Version 3
 * (http://www.fsf.org/licensing/licenses/agpl-3.0.html) with the
 * Commons Clause, as found in the associated LICENSE.txt file.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * Neo4j object code can be licensed independently from the source
 * under separate terms from the AGPL. Inquiries can be directed to:
 * licensing@neo4j.com
 *
 * More information is also available at:
 * https://neo4j.com/licensing/
 */
namespace Neo4Net.cluster.protocol.atomicbroadcast.multipaxos
{

	using Neo4Net.cluster.com.message;
	using MessageHolder = Neo4Net.cluster.com.message.MessageHolder;
	using ClusterMessage = Neo4Net.cluster.protocol.cluster.ClusterMessage;
	using Neo4Net.cluster.statemachine;

	/// <summary>
	/// State machine for Paxos Proposer
	/// </summary>
	public enum ProposerState
	{
//JAVA TO C# CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
//ORIGINAL LINE: start { @Override public ProposerState handle(ProposerContext context, org.neo4j.cluster.com.message.Message<ProposerMessage> message, org.neo4j.cluster.com.message.MessageHolder outgoing) { if(message.getMessageType() == ProposerMessage.join) { return proposer; } return this; } },
		 start
		 {
			 public ProposerState handle( ProposerContext context, Message<ProposerMessage> message, MessageHolder outgoing )
			 {
				 if ( message.MessageType == ProposerMessage.Join ) { return proposer; } return this;
			 }
		 },

//JAVA TO C# CONVERTER TODO TASK: Most Java annotations will not have direct .NET equivalent attributes:
//ORIGINAL LINE: proposer { @Override public ProposerState handle(ProposerContext context, org.neo4j.cluster.com.message.Message<ProposerMessage> message, org.neo4j.cluster.com.message.MessageHolder outgoing) { switch(message.getMessageType()) { case propose: { propose(context, message, outgoing, determineAcceptorSet(message, context)); break; } case rejectPrepare: { ProposerMessage.RejectPrepare rejectPropose = message.getPayload(); org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId instanceId = new org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId(message); PaxosInstance instance = context.getPaxosInstance(instanceId); context.getLog(ProposerState.class).debug("Propose for instance " + instance + " rejected from " + message.getHeader(org.neo4j.cluster.com.message.Message.HEADER_FROM) + " with ballot " + rejectPropose.getBallot()); if(instance.isState(PaxosInstance.State.p1_pending) && instance.getBallot() < rejectPropose.getBallot()) { long ballot = instance.ballot; while (ballot <= rejectPropose.getBallot()) { ballot += 1000; } instance.phase1Timeout(ballot); context.getLog(ProposerState.class).debug("Reproposing instance " + instance + " at ballot " + instance.ballot + " after rejectPrepare"); for(java.net.URI acceptor : instance.getAcceptors()) { outgoing.offer(message.copyHeadersTo(org.neo4j.cluster.com.message.Message.to(AcceptorMessage.prepare, acceptor, new AcceptorMessage.PrepareState(ballot)), org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } assert instance.value_1 == null : "value_1 should have been null at this point"; Object payload = context.getBookedInstance(instanceId).getPayload(); assert payload != null : "Should have a booked instance payload for " + instanceId; context.setTimeout(instanceId, message.copyHeadersTo(org.neo4j.cluster.com.message.Message.timeout(ProposerMessage.phase1Timeout, message, payload), org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } break; } case phase1Timeout: { org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId instanceId = new org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId(message); PaxosInstance instance = context.getPaxosInstance(instanceId); if(instance.isState(PaxosInstance.State.p1_pending)) { if(instance.ballot > 10000) { context.getLog(ProposerState.class).warn("Propose failed due to phase 1 " + "timeout"); org.neo4j.cluster.com.message.Message originalMessage = context.getBookedInstance(instance.id); outgoing.offer(originalMessage.copyHeadersTo(org.neo4j.cluster.com.message.Message.internal(AtomicBroadcastMessage.failed, originalMessage.getPayload()))); context.cancelTimeout(instanceId); } else { long ballot = instance.ballot + 1000; instance.phase1Timeout(ballot); for(java.net.URI acceptor : instance.getAcceptors()) { outgoing.offer(message.copyHeadersTo(org.neo4j.cluster.com.message.Message.to(AcceptorMessage.prepare, acceptor, new AcceptorMessage.PrepareState(ballot)), org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } context.setTimeout(instanceId, message.copyHeadersTo(org.neo4j.cluster.com.message.Message.timeout(ProposerMessage.phase1Timeout, message, message.getPayload()), org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } } else if(instance.isState(PaxosInstance.State.closed) || instance.isState(PaxosInstance.State.delivered)) { org.neo4j.cluster.com.message.Message oldMessage = context.unbookInstance(instance.id); context.getLog(getClass()).debug("Retrying instance " + instance.id + " with message " + message.getPayload() + ". Previous instance was " + oldMessage); outgoing.offer(org.neo4j.cluster.com.message.Message.internal(ProposerMessage.propose, message.getPayload())); } break; } case promise: { ProposerMessage.PromiseState promiseState = message.getPayload(); PaxosInstance instance = context.getPaxosInstance(new org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId(message)); if(instance.isState(PaxosInstance.State.p1_pending) && instance.ballot == promiseState.getBallot()) { instance.promise(promiseState); if(instance.isPromised(context.getMinimumQuorumSize(instance.getAcceptors()))) { context.cancelTimeout(instance.id); Object readyValue = instance.value_2 == null ? context.getBookedInstance(instance.id).getPayload() : instance.value_2; if(instance.value_1 == null) { instance.ready(readyValue, true); } else { if(instance.value_2 == null) { context.pendingValue(context.unbookInstance(instance.id)); instance.ready(instance.value_1, false); } else if(instance.value_1.equals(readyValue)) { instance.ready(instance.value_2, instance.clientValue); } else if(instance.clientValue) { context.pendingValue(context.unbookInstance(instance.id)); instance.ready(instance.value_1, false); } else { context.pendingValue(context.unbookInstance(instance.id)); instance.ready(instance.value_1, false); } } instance.pending(); for(java.net.URI acceptor : instance.getAcceptors()) { outgoing.offer(message.copyHeadersTo(org.neo4j.cluster.com.message.Message.to(AcceptorMessage.accept, acceptor, new AcceptorMessage.AcceptState(instance.ballot, instance.value_2)), org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } context.setTimeout(instance.id, message.copyHeadersTo(org.neo4j.cluster.com.message.Message.timeout(ProposerMessage.phase2Timeout, message, readyValue), org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } else { } } else { } break; } case rejectAccept: { org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId instanceId = new org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId(message); PaxosInstance instance = context.getPaxosInstance(instanceId); if(instance.isState(PaxosInstance.State.p2_pending)) { ProposerMessage.RejectAcceptState state = message.getPayload(); instance.rejected(state); if(!instance.isAccepted(context.getMinimumQuorumSize(instance.getAcceptors()))) { context.cancelTimeout(instanceId); context.getLog(ProposerState.class).warn("Accept rejected:" + instance.state); if(instance.clientValue) { org.neo4j.cluster.com.message.Message copyWithValue = org.neo4j.cluster.com.message.Message.internal(ProposerMessage.propose, instance.value_2); message.copyHeadersTo(copyWithValue); propose(context, copyWithValue, outgoing, instance.getAcceptors()); } } } break; } case phase2Timeout: { org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId instanceId = new org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId(message); PaxosInstance instance = context.getPaxosInstance(instanceId); if(instance.isState(PaxosInstance.State.p2_pending)) { long ballot = instance.ballot + 1000; instance.phase2Timeout(ballot); for(java.net.URI acceptor : instance.getAcceptors()) { outgoing.offer(message.copyHeadersTo(org.neo4j.cluster.com.message.Message.to(AcceptorMessage.prepare, acceptor, new AcceptorMessage.PrepareState(ballot)), org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } context.setTimeout(instanceId, message.copyHeadersTo(org.neo4j.cluster.com.message.Message.timeout(ProposerMessage.phase1Timeout, message, message.getPayload()), org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } else if(instance.isState(PaxosInstance.State.closed) || instance.isState(PaxosInstance.State.delivered)) { outgoing.offer(message.copyHeadersTo(org.neo4j.cluster.com.message.Message.internal(ProposerMessage.propose, message.getPayload()))); } break; } case accepted: { PaxosInstance instance = context.getPaxosInstance(new org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId(message)); if(instance.isState(PaxosInstance.State.p2_pending)) { ProposerMessage.AcceptedState acceptedState = message.getPayload(); instance.accepted(acceptedState); if(instance.accepts.size() >= context.getMinimumQuorumSize(instance.getAcceptors())) { context.cancelTimeout(instance.id); if(instance.value_2 instanceof org.neo4j.cluster.protocol.cluster.ClusterMessage.ConfigurationChangeState) { context.patchBookedInstances((org.neo4j.cluster.protocol.cluster.ClusterMessage.ConfigurationChangeState) instance.value_2); org.neo4j.cluster.protocol.cluster.ClusterMessage.ConfigurationChangeState state = (org.neo4j.cluster.protocol.cluster.ClusterMessage.ConfigurationChangeState) instance.value_2; for(java.net.URI learner : context.getMemberURIs()) { if(learner.equals(context.boundAt())) { outgoing.offer(message.copyHeadersTo(org.neo4j.cluster.com.message.Message.internal(LearnerMessage.learn, new LearnerMessage.LearnState(instance.value_2)), org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } else { outgoing.offer(message.copyHeadersTo(org.neo4j.cluster.com.message.Message.to(LearnerMessage.learn, learner, new LearnerMessage.LearnState(instance.value_2)), org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } } if(state.getJoin() != null) { outgoing.offer(message.copyHeadersTo(org.neo4j.cluster.com.message.Message.to(LearnerMessage.learn, state.getJoinUri(), new LearnerMessage.LearnState(instance.value_2)), org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } } else { for(java.net.URI learner : context.getMemberURIs()) { outgoing.offer(message.copyHeadersTo(org.neo4j.cluster.com.message.Message.to(LearnerMessage.learn, learner, new LearnerMessage.LearnState(instance.value_2)), org.neo4j.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } } context.unbookInstance(instance.id); if(context.hasPendingValues() && context.canBookInstance()) { org.neo4j.cluster.com.message.Message proposeMessage = context.popPendingValue(); context.getLog(ProposerState.class).debug("Restarting " + proposeMessage + " booked:" + context.nrOfBookedInstances()); outgoing.offer(proposeMessage); } } } else { context.getLog(ProposerState.class).debug("Instance receiving an accepted is in " + "the wrong state:" + instance); } break; } case leave: { context.leave(); return start; } default: break; } return this; } };
		 proposer { public ProposerState handle( ProposerContext context, Message<ProposerMessage> message, MessageHolder outgoing ) { switch ( message.MessageType ) { case propose: { propose( context, message, outgoing, determineAcceptorSet( message, context ) ); break; } case rejectPrepare: { ProposerMessage.RejectPrepare rejectPropose = message.Payload; Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId instanceId = new Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId( message ); PaxosInstance instance = context.getPaxosInstance( instanceId ); context.getLog( typeof( ProposerState ) ).debug( "Propose for instance " + instance + " rejected from " + message.getHeader( Message.HEADER_FROM ) + " with ballot " + rejectPropose.Ballot ); if ( instance.isState( PaxosInstance.State.P1Pending ) && instance.Ballot < rejectPropose.Ballot ) { long ballot = instance.ballot; while ( ballot <= rejectPropose.Ballot ) { ballot += 1000; } instance.phase1Timeout( ballot ); context.getLog( typeof( ProposerState ) ).debug( "Reproposing instance " + instance + " at ballot " + instance.ballot + " after rejectPrepare" ); for ( URI acceptor : instance.Acceptors ) { outgoing.offer( message.copyHeadersTo( Message.to( AcceptorMessage.Prepare, acceptor, new AcceptorMessage.PrepareState( ballot ) ), Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE ) ); } assert instance.value_1 == null : "value_1 should have been null at this point"; object payload = context.getBookedInstance( instanceId ).Payload; assert payload != null : "Should have a booked instance payload for " + instanceId; context.setTimeout( instanceId, message.copyHeadersTo( Message.timeout( ProposerMessage.Phase1Timeout, message, payload ), Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE ) ); } break; } case phase1Timeout: { Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId instanceId = new Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId( message ); PaxosInstance instance = context.getPaxosInstance( instanceId ); if ( instance.isState( PaxosInstance.State.P1Pending ) ) { if ( instance.ballot > 10000 ) { context.getLog( typeof( ProposerState ) ).warn( "Propose failed due to phase 1 " + "timeout" ); Message originalMessage = context.getBookedInstance( instance.id ); outgoing.offer( originalMessage.copyHeadersTo( Message.@internal( AtomicBroadcastMessage.Failed, originalMessage.Payload ) ) ); context.cancelTimeout( instanceId ); } else { long ballot = instance.ballot + 1000; instance.phase1Timeout( ballot ); for ( URI acceptor : instance.Acceptors ) { outgoing.offer( message.copyHeadersTo( Message.to( AcceptorMessage.Prepare, acceptor, new AcceptorMessage.PrepareState( ballot ) ), Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE ) ); } context.setTimeout( instanceId, message.copyHeadersTo( Message.timeout( ProposerMessage.Phase1Timeout, message, message.Payload ), Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE ) ); } } else if ( instance.isState( PaxosInstance.State.Closed ) || instance.isState( PaxosInstance.State.Delivered ) ) { Message oldMessage = context.unbookInstance( instance.id ); context.getLog( this.GetType() ).debug("Retrying instance " + instance.id + " with message " + message.Payload + ". Previous instance was " + oldMessage); outgoing.offer(Message.@internal(ProposerMessage.Propose, message.Payload)); } break; } case promise: { ProposerMessage.PromiseState promiseState = message.Payload; PaxosInstance instance = context.getPaxosInstance(new Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId(message)); if (instance.isState(PaxosInstance.State.P1Pending) && instance.ballot == promiseState.Ballot) { instance.promise(promiseState); if (instance.isPromised(context.getMinimumQuorumSize(instance.Acceptors))) { context.cancelTimeout(instance.id); object readyValue = instance.value_2 == null ? context.getBookedInstance(instance.id).Payload : instance.value_2; if (instance.value_1 == null) { instance.ready(readyValue, true); } else { if (instance.value_2 == null) { context.pendingValue(context.unbookInstance(instance.id)); instance.ready(instance.value_1, false); } else if (instance.value_1.Equals(readyValue)) { instance.ready(instance.value_2, instance.clientValue); } else if (instance.clientValue) { context.pendingValue(context.unbookInstance(instance.id)); instance.ready(instance.value_1, false); } else { context.pendingValue(context.unbookInstance(instance.id)); instance.ready(instance.value_1, false); } } instance.pending(); for (URI acceptor : instance.Acceptors) { outgoing.offer(message.copyHeadersTo(Message.to(AcceptorMessage.Accept, acceptor, new AcceptorMessage.AcceptState(instance.ballot, instance.value_2)), Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } context.setTimeout(instance.id, message.copyHeadersTo(Message.timeout(ProposerMessage.Phase2Timeout, message, readyValue), Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } else { } } else { } break; } case rejectAccept: { Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId instanceId = new Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId(message); PaxosInstance instance = context.getPaxosInstance(instanceId); if (instance.isState(PaxosInstance.State.P2Pending)) { ProposerMessage.RejectAcceptState state = message.Payload; instance.rejected(state); if (!instance.isAccepted(context.getMinimumQuorumSize(instance.Acceptors))) { context.cancelTimeout(instanceId); context.getLog(typeof(ProposerState)).warn("Accept rejected:" + instance.state); if (instance.clientValue) { Message copyWithValue = Message.@internal(ProposerMessage.Propose, instance.value_2); message.copyHeadersTo(copyWithValue); propose(context, copyWithValue, outgoing, instance.Acceptors); } } } break; } case phase2Timeout: { Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId instanceId = new Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId(message); PaxosInstance instance = context.getPaxosInstance(instanceId); if (instance.isState(PaxosInstance.State.P2Pending)) { long ballot = instance.ballot + 1000; instance.phase2Timeout(ballot); for (URI acceptor : instance.Acceptors) { outgoing.offer(message.copyHeadersTo(Message.to(AcceptorMessage.Prepare, acceptor, new AcceptorMessage.PrepareState(ballot)), Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } context.setTimeout(instanceId, message.copyHeadersTo(Message.timeout(ProposerMessage.Phase1Timeout, message, message.Payload), Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } else if (instance.isState(PaxosInstance.State.Closed) || instance.isState(PaxosInstance.State.Delivered)) { outgoing.offer(message.copyHeadersTo(Message.@internal(ProposerMessage.Propose, message.Payload))); } break; } case accepted: { PaxosInstance instance = context.getPaxosInstance(new Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId(message)); if (instance.isState(PaxosInstance.State.P2Pending)) { ProposerMessage.AcceptedState acceptedState = message.Payload; instance.accepted(acceptedState); if (instance.accepts.size() >= context.getMinimumQuorumSize(instance.Acceptors)) { context.cancelTimeout(instance.id); if (instance.value_2 is ClusterMessage.ConfigurationChangeState) { context.patchBookedInstances((ClusterMessage.ConfigurationChangeState) instance.value_2); ClusterMessage.ConfigurationChangeState state = (ClusterMessage.ConfigurationChangeState) instance.value_2; for (URI learner : context.MemberURIs) { if (learner.Equals(context.boundAt())) { outgoing.offer(message.copyHeadersTo(Message.@internal(LearnerMessage.Learn, new LearnerMessage.LearnState(instance.value_2)), Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } else { outgoing.offer(message.copyHeadersTo(Message.to(LearnerMessage.Learn, learner, new LearnerMessage.LearnState(instance.value_2)), Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } } if (state.Join != null) { outgoing.offer(message.copyHeadersTo(Message.to(LearnerMessage.Learn, state.JoinUri, new LearnerMessage.LearnState(instance.value_2)), Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } } else { for (URI learner : context.MemberURIs) { outgoing.offer(message.copyHeadersTo(Message.to(LearnerMessage.Learn, learner, new LearnerMessage.LearnState(instance.value_2)), Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE)); } } context.unbookInstance(instance.id); if (context.hasPendingValues() && context.canBookInstance()) { Message proposeMessage = context.popPendingValue(); context.getLog(typeof(ProposerState)).debug("Restarting " + proposeMessage + " booked:" + context.nrOfBookedInstances()); outgoing.offer(proposeMessage); } } } else { context.getLog(typeof(ProposerState)).debug("Instance receiving an accepted is in " + "the wrong state:" + instance); } break; } case leave: { context.leave(); return start; } default: break; } return this; } };

		 private static void propose( ProposerContext context, Message message, MessageHolder outgoing, IList<URI> acceptors )
		 {
			 Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId instanceId; if ( message.hasHeader( Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE ) ) { instanceId = new Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId( message ); } else { instanceId = context.newInstanceId(); message.setHeader(Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE, instanceId.ToString()); context.bookInstance(instanceId, message); } long ballot = 1000 + context.MyId.toIntegerIndex(); PaxosInstance instance = context.getPaxosInstance(instanceId); if (instance.Acceptors != null) { acceptors = instance.Acceptors; } if (!(instance.isState(PaxosInstance.State.Closed) || instance.isState(PaxosInstance.State.Delivered)))
			 {
				 instance.propose( ballot, acceptors ); for ( URI acceptor : acceptors ) { outgoing.offer( Message.to( AcceptorMessage.Prepare, acceptor, new AcceptorMessage.PrepareState( ballot ) ).setHeader( Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE, instanceId.ToString() ) ); } context.setTimeout(instanceId, Message.timeout(ProposerMessage.Phase1Timeout, message, message.Payload).setHeader(Neo4Net.cluster.protocol.atomicbroadcast.multipaxos.InstanceId.INSTANCE, instanceId.ToString()));
			 }
			 else { context.pendingValue( message ); }
		 }
		 private static IList<URI> determineAcceptorSet( Message<ProposerMessage> message, ProposerContext context )
		 {
			 object payload = message.Payload; if ( payload is ClusterMessage.ConfigurationChangeState )
			 {
				 ClusterMessage.ConfigurationChangeState state = message.Payload; IList<URI> acceptors = context.Acceptors; IDictionary<Neo4Net.cluster.InstanceId, URI> currentMembers = context.Members; if ( state.Leave != null ) { acceptors = new List<>( acceptors ); acceptors.remove( currentMembers.get( state.Leave ) ); } if ( state.Join != null && currentMembers.containsKey( state.Join ) )
				 {
					 acceptors.remove( currentMembers.get( state.Join ) ); if ( !acceptors.contains( state.JoinUri ) ) { acceptors.add( state.JoinUri ); }
				 }
				 return acceptors;
			 }
			 else { return context.Acceptors; }
		 }
	}

}