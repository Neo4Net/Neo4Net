using System;

/*
 * Copyright © 2018-2020 "Neo4Net,"
 * Team NeoN [http://neo4net.com]. All Rights Reserved.
 *
 * This file is part of Neo4Net.
 *
 * Neo4Net is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
namespace Neo4Net.Kernel.impl.util.dbstructure
{

	using Neo4Net.Helpers.Collections;

	public class InvocationTracer<C> : InvocationHandler, IDisposable
	{
		 private readonly string _generatorInfo;

		 private readonly string _generatedClassPackage;
		 private readonly string _generatedClassName;

		 private readonly Type<C> _interfaceClass;
		 private readonly ArgumentFormatter _argumentFormatter;
		 private readonly Appendable _output;

		 private bool _open = true;

//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in C#:
//ORIGINAL LINE: public InvocationTracer(String generatorInfo, String generatedClassPackage, String generatedClassName, Class<C> interfaceClass, ArgumentFormatter argumentFormatter, Appendable output) throws java.io.IOException
		 public InvocationTracer( string generatorInfo, string generatedClassPackage, string generatedClassName, Type interfaceClass, ArgumentFormatter argumentFormatter, Appendable output )
		 {
				 interfaceClass = typeof( C );
			  this._generatorInfo = generatorInfo;

			  if ( generatedClassName.Contains( "." ) || generatedClassName.Contains( "%" ) )
			  {
					throw new System.ArgumentException( "Invalid class name: " + generatedClassName );
			  }

			  if ( generatedClassPackage.Contains( "%" ) )
			  {
					throw new System.ArgumentException( "Invalid class package: " + generatedClassPackage );
			  }

			  this._generatedClassPackage = generatedClassPackage;
			  this._generatedClassName = generatedClassName;
			  this._interfaceClass = interfaceClass;
			  this._argumentFormatter = argumentFormatter;
			  this._output = output;

			  FormatPreamble( output );
		 }

		 public virtual C NewProxy()
		 {
			  return NewProxy( _interfaceClass );
		 }

		 public virtual P NewProxy<P>( Type proxyClass ) where P : C
		 {
				 proxyClass = typeof( P );
			  ClassLoader classLoader = proxyClass.ClassLoader;
			  return proxyClass.cast( Proxy.newProxyInstance( classLoader, new Type[]{ proxyClass }, this ) );
		 }

//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in C#:
//ORIGINAL LINE: public void close() throws java.io.IOException
		 public override void Close()
		 {
			  if ( _open )
			  {
					FormatAppendix( _output );
					_open = false;
			  }
			  else
			  {
					throw new System.InvalidOperationException( "Already closed" );
			  }
		 }

//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in C#:
//ORIGINAL LINE: private void formatPreamble(Appendable builder) throws java.io.IOException
		 private void FormatPreamble( Appendable builder )
		 {
			  string interfaceSimpleName = _interfaceClass.Name;
//JAVA TO C# CONVERTER WARNING: The .NET Type.FullName property will not always yield results identical to the Java Class.getCanonicalName method:
			  string interfaceClassName = interfaceSimpleName.Length == 0 ? _interfaceClass.FullName : interfaceSimpleName;
			  if ( _generatedClassPackage.Length > 0 )
			  {
					Formatln( builder, "package %s;", _generatedClassPackage );
					Formatln( builder );
			  }
//JAVA TO C# CONVERTER WARNING: The .NET Type.FullName property will not always yield results identical to the Java Class.getCanonicalName method:
			  Formatln( builder, "import %s;", typeof( Visitable ).FullName );
//JAVA TO C# CONVERTER WARNING: The .NET Type.FullName property will not always yield results identical to the Java Class.getCanonicalName method:
			  Formatln( builder, "import %s;", _interfaceClass.FullName );
			  Formatln( builder );
			  foreach ( string importExpr in _argumentFormatter.imports() )
			  {
					Formatln( builder, "import %s;", importExpr );
			  }
			  Formatln( builder );
			  Formatln( builder, "//" );
			  Formatln( builder, "// GENERATED FILE. DO NOT EDIT." );
			  Formatln( builder, "//" );
			  Formatln( builder, "// This has been generated by:" );
			  Formatln( builder, "//" );
			  if ( _generatorInfo.Length > 0 )
			  {
					Formatln( builder, "//   %s", _generatorInfo );
					Formatln( builder, "//" );
//JAVA TO C# CONVERTER WARNING: The .NET Type.FullName property will not always yield results identical to the Java Class.getCanonicalName method:
					Formatln( builder, "// (using %s)", this.GetType().FullName );
					Formatln( builder, "//" );
			  }
			  else
			  {
//JAVA TO C# CONVERTER WARNING: The .NET Type.FullName property will not always yield results identical to the Java Class.getCanonicalName method:
					Formatln( builder, "//   %s", this.GetType().FullName );
					Formatln( builder, "//" );
			  }
			  Formatln( builder );
			  Formatln( builder, "public enum %s", _generatedClassName );
			  Formatln( builder, "implements %s<%s>", typeof( Visitable ).Name, interfaceClassName );
			  Formatln( builder, "{" );
			  Formatln( builder, "    INSTANCE;" );
			  Formatln( builder );
			  Formatln( builder, "    public void accept( %s visitor )", interfaceClassName );
			  Formatln( builder, "    {" );
		 }

//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in C#:
//ORIGINAL LINE: public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
		 public override object Invoke( object proxy, System.Reflection.MethodInfo method, object[] args )
		 {
			  if ( _open )
			  {
					if ( method.ReturnType.Equals( Void.TYPE ) )
					{
						 // formatln invocation start
						 Format( _output, "        visitor.%s(", method.Name );

						 // formatln arguments
						 for ( int i = 0; i < args.Length; i++ )
						 {
							  object arg = args[i];

							  if ( i > 0 )
							  {
									Format( _output, ", " );
							  }
							  else
							  {
									Format( _output, " " );
							  }

							  _argumentFormatter.formatArgument( _output, arg );
						 }

						 // formatln invocation end
						 if ( args.Length == 0 )
						 {
							  Formatln( _output, ");" );
						 }
						 else
						 {
							  Formatln( _output, " );" );
						 }

						 return null;
					}
					else
					{
						 throw new System.ArgumentException( "InvocationTraceGenerator only works with void methods" );
					}
			  }
			  else
			  {
					throw new System.InvalidOperationException( "Tracer already closed" );
			  }
		 }

//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in C#:
//ORIGINAL LINE: private static void formatAppendix(Appendable builder) throws java.io.IOException
		 private static void FormatAppendix( Appendable builder )
		 {
			  Formatln( builder, "   }" );
			  Formatln( builder, "}" );
			  Formatln( builder );
			  Formatln( builder, "/* END OF GENERATED CONTENT */" );
		 }

//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in C#:
//ORIGINAL LINE: private static void formatln(Appendable output, String format, Object... args) throws java.io.IOException
		 private static void Formatln( Appendable output, string format, params object[] args )
		 {
			  format( output, format, args );
			  Formatln( output );
		 }

//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in C#:
//ORIGINAL LINE: private static void format(Appendable output, String format, Object... args) throws java.io.IOException
		 private static void Format( Appendable output, string format, params object[] args )
		 {
			  output.append( string.format( format, args ) );
		 }

//JAVA TO C# CONVERTER WARNING: Method 'throws' clauses are not available in C#:
//ORIGINAL LINE: private static void formatln(Appendable output) throws java.io.IOException
		 private static void Formatln( Appendable output )
		 {
			  output.append( Environment.NewLine );
		 }
	}

}